import * as path from "path";
import * as fs from "fs";

import * as yaml from "js-yaml";

import * as core from "@actions/core";

import * as types from "../types";
import * as conda from "../conda";

import { ensureExplicit } from "./explicit";
import { ensureYaml } from "./yaml";
import { ensureSimple } from "./simple";

/**
 * The current known providers of envs
 *
 * ### Note
 * To add a new env creation mechanism,
 * - implement IEnvProvider and add it here
 * - probably add inputs to `../../action.yaml`
 * - add any new RULEs in ../input.ts, for example if certain inputs make no sense
 * - add a test!
 */
const ENV_PROVIDERS: types.IEnvProvider[] = [
  ensureExplicit,
  ensureSimple,
  ensureYaml,
];

/**
 * Create test environment, or update the base environment
 */
export async function ensureEnvironment(
  inputs: types.IActionInputs,
  options: types.IDynamicOptions
): Promise<void> {
  for (const provider of ENV_PROVIDERS) {
    core.info(`Can we ${provider.label}?`);
    if (await provider.provides(inputs, options)) {
      core.info(`... will ${provider.label}.`);
      const args = await provider.condaArgs(inputs, options);
      return await core.group(
        `Updating '${inputs.activateEnvironment}' env from ${provider.label}...`,
        () => conda.condaCommand(args, options)
      );
    }
  }

  throw Error(
    `'activate-environment: ${inputs.activateEnvironment}' could not be created`
  );
}

/**
 * Check if a given conda environment exists
 */
export function environmentExists(
  inputs: types.IActionInputs,
  options: types.IDynamicOptions
): boolean {
  const condaMetaPath = path.join(
    conda.condaBasePath(options),
    "envs",
    inputs.activateEnvironment,
    "conda-meta"
  );
  return fs.existsSync(condaMetaPath);
}

/**
 * Read and potentially parse the `environment-file`
 *
 * ### Notes
 * Currently supports a single:
 * - YAML (as accepted by `conda env update`)
 * - lock (as generated by `conda list --explict` or `conda lock`)
 *
 * In the future, this could be provided in different ways, including
 * multiple files, alternate inputs, etc.
 */
export async function getEnvSpec(
  inputs: types.IActionInputs
): Promise<types.IEnvSpec> {
  if (!inputs.environmentFile) {
    return {};
  }

  const sourceEnvironmentPath: string = path.join(
    process.env["GITHUB_WORKSPACE"] || "",
    inputs.environmentFile
  );

  const source = fs.readFileSync(sourceEnvironmentPath, "utf8");

  if (source.match(/^@EXPLICIT/m)) {
    return { explicit: source, yaml: {} };
  }

  return { yaml: yaml.safeLoad(source) as types.IEnvironment };
}
